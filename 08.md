# Workshop 8 â€” Events and Authentication

# ğŸ¯ Objective

Learn to integrate **events and user authentication** into our contract, so that we can **obtain reliable information about the actions performed** and ensure that only authorized users can execute critical functions, guaranteeing security and traceability in the interaction with the contract.

## ğŸ”¹ Events in a Smart Contract and Their Relevance

Events are messages that the contract **emits every time a relevant action occurs**, such as the creation of a rental, a deposit, or a withdrawal. Their main function is to **immediately notify that something happened** inside the contract, allowing any external system or interface to react to those changes without needing to repeatedly query the contract's state.

By integrating events, we can build a **reliable record of all critical operations**, which facilitates tracking actions by users and administrators, and also improves **traceability and transparency**. Events also allow separating the contract's internal logic from how data is presented, offering a **safe and efficient channel to communicate results** and important updates.

In the context of our car rental contract, for example, every time a car is rented or a payment is made, an event allows us to **know exactly which user performed which action and when**, without needing to manually check each record in the contract's storage. This ensures the information we receive is **reliable and verifiable**, and helps **detect errors or inconsistencies quickly**.

## ğŸ”¹ User Authentication and Permission Control

Authentication in a smart contract allows us to **verify that the user invoking a function is indeed who they claim to be**, meaning they possess the private key corresponding to the address signing the transaction. This is fundamental to **guarantee the security and integrity of operations**, preventing unauthorized third parties from executing actions that could compromise the contract or affect other users.

Thanks to authentication, we can **control which type of user can execute each function** of our contract. For example, in our car rental system, certain functions must be restricted: only the admin can add new cars or remove them, while only the owner of a car can collect a payment associated with their vehicle. This allows implementing **clear access and responsibility rules**, ensuring that every action has a legitimate actor behind it and that all operations are traceable and reliable.

In summary, authentication not only protects the funds and resources within the contract but also provides us with a mechanism to **organize roles and permissions**, making the interaction with the contract secure, orderly, and transparent.

# ğŸ’» **Guided Demo: Adding Authentication to the Contract**

In Soroban, this is achieved with the `require_auth()` method which ensures that the **address signing the transaction** matches the **address attempting to execute the action**.

> âš™ï¸ In other words: we verify the sender's identity before modifying the contract's state.
>
> This allows us to define roles, permissions, and restrictions based on the user type or action.

### ğŸ”¹ Administrator Authentication

When the contract is initialized, an **administrator** is defined (usually the account that deploys the contract).

Thanks to authentication, we can ensure that **only this administrator can execute critical functions**, such as **adding or removing cars** from the system.

> ğŸ’¡ For example, when executing `add_car` or `remove_car`, the contract will validate that the account making the call is the same one registered as admin during initialization.

This is achieved by adding a verification at the start of the function:

```rust
let admin = read_admin(env);
admin.require_auth();
```

This way, if any other user attempts to execute a restricted action, the transaction will automatically fail.

---

### ğŸ”¹ Owner Authentication (Car Owner)

The **car owner** must also authenticate when performing actions that belong exclusively to them, such as **receiving payments or claiming earnings**.

> ğŸ’¡ This prevents a third party from attempting to execute financial functions on behalf of the owner.

For this we use:

```rust
owner.require_auth();
```

This line guarantees that **only the real owner of the car** has signed the transaction, validating their intent before executing the action.

---

### ğŸ”¹ Renter Authentication

Finally, the **renter** (user renting the car) must authenticate before starting or ending a rental.

This ensures that **only the involved renter** can perform those operations.

```rust
renter.require_auth();
```

> ğŸ’¡ This way, we confirm that the user renting the vehicle is indeed the one signing the transaction, preventing misuse or fraud within the system.

---

## ğŸ”¹ Benefits of Implementing Authentication

Integrating authentication into the smart contract provides us with multiple advantages:

- ğŸ§© **Role Security**: ensures only the correct users execute specific actions.
- ğŸ”’ **Data Protection**: prevents improper modifications to the ledger.
- ğŸ“œ **Clear Auditing**: every transaction is associated with a verifiable signature.
- âš¡ **Controlled Permission Flow**: hierarchies (admin, renter, owner) can be established with independent access logic.

# ğŸ”’ **List of Tests with Authentication Validation**

In this section, we validate that **only authorized accounts can execute certain contract functions**, according to their role (admin, owner, or renter).

To simulate signatures and permissions, we use `mock_auths`, which allows us to specify **which address authorizes** the call and with which parameters.

---

### ğŸ”¹ Auth for `add_car`

ğŸ“„ `src/tests/auth/add_car.rs`

```rust
use soroban_sdk::{testutils::{Address as _, MockAuth, MockAuthInvoke}, IntoVal, Address};

#[test]
#[should_panic(expected = "Error(Auth, InvalidAction)")]
pub fn test_unauthorized_user_cannot_add_car() {
    let ContractTest { env, contract, .. } = ContractTest::setup();

		let fake_admin = Address::generate(&env);
    let owner = Address::generate(&env);
    let price_per_day = 1500_i128;

    contract
        .mock_auths(&[MockAuth {
            address: &fake_admin,
            invoke: &MockAuthInvoke {
                contract: &contract.address.clone(),
                fn_name: "add_car",
                args: (owner.clone(), price_per_day).into_val(&env),
                sub_invokes: &[],
            },
        }]).add_car(&owner, &price_per_day);
}
```

> ğŸ’¡ Ensures only the authenticated admin can list new cars in the system.

---

### ğŸ”¹ Auth for `remove_car`

ğŸ“„ `src/tests/auth/remove_car.rs`

```rust
use soroban_sdk::{testutils::{Address as _, MockAuth, MockAuthInvoke}, IntoVal, Address};

#[test]
#[should_panic(expected = "Error(Auth, InvalidAction)")]
pub fn test_unauthorized_user_cannot_remove_car() {
    let ContractTest { env, contract, .. } = ContractTest::setup();

		let fake_admin = Address::generate(&env);
    let owner = Address::generate(&env);

    contract
        .mock_auths(&[MockAuth {
            address: &fake_admin ,
            invoke: &MockAuthInvoke {
                contract: &contract.address.clone(),
                fn_name: "remove_car",
                args: (owner.clone(),).into_val(&env),
                sub_invokes: &[],
            },
        }]).remove_car(&owner);
}
```

> ğŸ’¡ This test prevents external accounts from deleting cars without admin authorization.

---

### ğŸ”¹ Auth for `rental`

ğŸ“„ `src/tests/auth/rental.rs`

```rust
use soroban_sdk::testutils::{testutils::{Address as _, MockAuth, MockAuthInvoke}, Address};

#[test]
#[should_panic(expected = "Error(Auth, InvalidAction)")]
pub fn test_unauthorized_user_cannot_rent_car() {
    let ContractTest { env, contract, .. } = ContractTest::setup();

    let fake_renter = Address::generate(&env);
    let renter = Address::generate(&env);
    let owner = Address::generate(&env);
    let total_days = 3_i128;
    let amount = 4500_i128;

    contract
        .mock_auths(&[MockAuth {
            address: &fake_renter,
            invoke: &MockAuthInvoke {
                contract: &contract.address.clone(),
                fn_name: "rental",
                args: (renter.clone(), owner.clone(), total_days, amount).into_val(&env),
                sub_invokes: &[],
            },
        }]).rental(&renter, &owner, &total_days, &amount);
}
```

> ğŸ’¡ Confirms that only the renter can authorize the action of renting a vehicle.

---

### ğŸ”¹ Auth for `payout_owner`

ğŸ“„ `src/tests/auth/payout_owner.rs`

```rust
use soroban_sdk::testutils::{testutils::{Address as _, MockAuth, MockAuthInvoke}, Address};

#[test]
#[should_panic(expected = "Error(Auth, InvalidAction)")]
pub fn test_unauthorized_user_cannot_payout_owner() {
    let ContractTest { env, contract, .. } = ContractTest::setup();

    let owner = Address::generate(&env);
    let fake_owner = Address::generate(&env);
    let amount = 4500_i128;

    contract
        .mock_auths(&[MockAuth {
            address: &fake_owner,
            invoke: &MockAuthInvoke {
                contract: &contract.address.clone(),
                fn_name: "payout_owner",
                args: (owner.clone(), amount).into_val(&env),
                sub_invokes: &[],
            },
        }]).payout(&owner, &amount);
}
```

> ğŸ’¡ Ensures only the authenticated owner can withdraw funds from the contract.

---

### ğŸ§­ Conclusion

These tests cover the authentication of the three main roles:

- ğŸ§‘â€ğŸ’¼ **Admin** â†’ controls `add_car`, `remove_car`, `set_admin`.
- ğŸš— **Owner** â†’ controls `payout_owner`.
- ğŸ‘¤ **Renter** â†’ controls `rental`.

Each one validates that the contract **correctly restricts operations** based on the signing identity, ensuring integrity and security in the system flow.

# ğŸ’» **Guided Demo: Creating Events in the Contract**

## ğŸ”¹ Anatomy of an Event in Soroban

An **event** in Soroban is a message that the contract **publishes every time an important action occurs**. Its basic structure is defined using `env.events().publish()`, which receives two parameters: `topics` and `data`. The `topics` are labels that allow **classifying and filtering events**, such as the type of action or the user involved, while `data` contains the specific information of the action, such as amounts, object IDs, or user addresses.

When deciding what to include in `topics` and what in `data`, it's best to **put in topics the elements we want to use for searching or grouping events** and in `data` all the additional information describing the event. This improves traceability and allows any observer or interface to process events efficiently and understandably.

ğŸ“„ `src/events/mod.rs`

```rust
pub mod contract;
pub mod remove_car;
pub mod payout_owner;
pub mod rental;
pub mod add_car;
```

## ğŸ”¹ `initialize` Event

This event is triggered **when the contract is created and the main parameters are initialized**, such as the administrator and the payment token. It allows having a clear record of the contract's initial configuration.

ğŸ“„ `src/events/contract.rs`

```rust
 use soroban_sdk::{Address, Env, Symbol};

pub(crate) fn contract_initialized(env: &Env, admin: Address, token: Address) {
    let topics = (Symbol::new(env, "contract_initialized"),);

    env.events().publish(
        topics,
        (admin, token)
    );
}
```

> ğŸ’¡ This event is important because it documents the contract's creation and ensures all users can verify what the initial admin and token were.

---

## ğŸ”¹ `add_car` Event

This event is triggered when a new car is added to the system by the administrator, recording the car's owner and the price per day.

ğŸ“„ `src/events/add_car.rs`

```rust
use soroban_sdk::{Address, Env, Symbol};

pub(crate) fn car_added(env: &Env, owner: Address, price_per_day: i128) {
    let topics = (Symbol::new(env, "car_added"), owner.clone());

    env.events().publish(
        topics,
        price_per_day
    );
}
```

> ğŸ’¡ Allows tracking the listing of cars, facilitating verification that each added car is visible and correctly registered in the system.

---

## ğŸ”¹ `rental` Event

This event is generated when a user rents a car, indicating who rented, who owns the car, the rental duration, and the amount.

ğŸ“„ `src/events/rental.rs`

```rust
pub(crate) fn rented(
    env: &Env,
    renter: Address,
    owner: Address,
    total_days: u32,
    amount: i128
) {
    let topics = (Symbol::new(env, "rented"), renter.clone(), owner.clone());

    env.events().publish(
        topics,
        (total_days, amount)
    );
}
```

> ğŸ’¡ Helps maintain a history of all reservations made, reliably showing actions within the contract and facilitating auditing.

## ğŸ”¹ `payout_owner` Event

This event is emitted when the owner of a car receives payment for a rental, indicating the transferred amount and which user was paid.

ğŸ“„ `src/events/payout_owner.rs`

```rust
use soroban_sdk::{Address, Env, Symbol};

pub(crate) fn payout_owner(env: &Env, owner: Address, amount: i128) {
    let topics = (Symbol::new(env, "payout"), owner.clone());

    env.events().publish(
        topics,
        amount
    );
}
```

> ğŸ’¡ Serves to maintain transparent control of payments made to owners, ensuring each transfer is recorded and can be verified.

## ğŸ”¹ `remove_car` Event

This event is triggered when a car is removed from the system, recording the owner of the car that was deleted.

ğŸ“„ `src/events/remove_car.rs`

```rust
use soroban_sdk::{Address, Env, Symbol};

pub(crate) fn car_removed(env: &Env, owner: Address) {
    let topics = (Symbol::new(env, "car_removed"), owner.clone());

    env.events().publish(
        topics,
        ()
    );
}
```

> ğŸ’¡ Ensures the deletion of cars is recorded, preventing inconsistencies and offering traceability over changes in the car catalog.

We export them to our contract and add each one, at the end of its corresponding function, as follows:

```rust
events::contract::contract_initialized(env, admin, token);
events::add_car::car_added(env, owner, price_per_day);
events::rental::rented(env, renter, owner, total_days_to_rent, amount);
events::payout_owner::payout_owner(env, owner, amount);
events::remove_car::car_removed(env, owner);
```

# ğŸƒâ€â™‚ï¸ **Running and Testing on Testnet**

Once the contract is deployed on Soroban, we can verify that events are triggered correctly using `stellar contract invoke` and reviewing the transaction output on the network.

### ğŸ”¹ Create Owner and User Accounts

As before, we must generate the `owner` and `user` accounts to be able to follow the practical example. These accounts will be necessary to interact with the contract and generate the corresponding events. You can create them using the **Stellar CLI** or directly in [**Stellar Laboratory**](https://lab.stellar.org/).

### 1ï¸âƒ£ Initialize the Contract

First, we delete the `wasm32v1-none` folder and compile the contract:

```bash
# Step 1
cargo build --target wasm32v1-none --release

# Step 2
stellar contract optimize --wasm target/wasm32v1-none/release/rent_a_car.wasm

```

Then we run the constructor (`__constructor`) to set the admin and the payment token, which will also trigger the initialization event:

```bash
stellar contract deploy `
  --wasm target/wasm32v1-none/release/rent_a_car.optimized.wasm `
  --source admin `
  --network testnet `
  -- `
  --admin <admin_public_key> `
  --token CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HHGCYSC
```

> ğŸ’¡ The event emitted by initialize will allow confirming that the contract was deployed correctly, recording the admin and payment token on the network.

### 2ï¸âƒ£ Add a Car and Generate its Event

When the admin lists a new car, an `add_car` event is emitted. This allows us to immediately verify in the transaction who the owner is and what the car's price is:

```bash
stellar contract invoke `
  --id <contract_id> `
  --source admin `
  --network testnet `
  -- `
  add_car `
  --owner <owner_address> `
  --price_per_day 1500
```

> ğŸ’¡ Thanks to this event, we can audit that each added car is registered and that the action was executed correctly, without needing to constantly query the contract's state.

### 3ï¸âƒ£ Perform a Rental and Capture the Event

When a user rents a car, the contract emits the `rental` event. This event includes who rented, who owns the car, the duration, and the amount paid:

```bash
stellar contract invoke `
  --id <contract_id> `
  --source <renter_secret_key> `
  --network testnet `
  -- `
  rental `
  --renter <renter_address> `
  --owner <owner_address> `
  --total_days_to_rent 3 `
  --amount 4500
```

> ğŸ’¡ The `rental` event allows maintaining a reliable history of reservations and payments, improving the traceability of operations within the contract.

### 4ï¸âƒ£ Payout to Owner and Payment Event

When the car owner receives payment for the rental, the `payout_owner` event is triggered, recording the transferred amount and the receiving account:

```bash
stellar contract invoke `
  --id <contract_id> `
  --source <owner_secret_key> `
  --network testnet `
  -- `
  payout_owner `
  --owner <owner_address> `
  --amount 4500
```

> ğŸ’¡ This event ensures that each payment made to the owner is reliably recorded, facilitating audits and fund tracking.

### 5ï¸âƒ£ Remove a Car and its Event

Finally, when the admin deletes a car from the contract, the `remove_car` event is emitted, showing which car was removed and by whom:

```bash
stellar contract invoke `
  --id <contract_id> `
  --source admin `
  --network testnet `
  -- `
  remove_car `
  --owner <owner_address>
```

> ğŸ’¡ The `remove_car` event ensures all critical actions for maintaining the car catalog are recorded and traceable on the blockchain.

# **ğŸ§ª Event Testing Explanation**

To test that our events are triggered correctly within the contract, we can leverage the test file we already have configured. We only need to **add a function that allows us to retrieve all events emitted** by the contract during the execution of each test. This will allow us to analyze the `topics` and `data` of the events easily and consistently.

## Initial Setup

ğŸ“„ `src/tests/config/utils.rs`

```rust
use soroban_sdk::{testutils::Events, token, vec, Address, Env, Val, Vec};

pub(crate) fn get_contract_events(
    env: &Env,
    contract_address: &Address,
) -> Vec<(Address, Vec<Val>, Val)> {
    let mut contract_events = Vec::new(env);

    env.events()
        .all()
        .iter()
        .filter(|event| event.0 == contract_address.clone())
        .for_each(|event| contract_events.push_back(event));

    contract_events
}
```

> ğŸ’¡ This file allows us to simulate transactions, invoke contract functions, and then retrieve all emitted events to analyze them in the tests.

## List of Tests with Event Capture

Once the environment is configured, we can create tests that invoke contract functions and verify that the emitted events contain the expected information:

### ğŸ”¹ `initialize` Event

ğŸ“„ `src/tests/initialize.rs`

```rust
use soroban_sdk::{vec, Symbol, IntoVal};
use crate::tests::config::{contract::ContractTest, utils::get_contract_events};

#[test]
pub fn test_initialize() {
    let ContractTest { env, contract, admin, token, .. } = ContractTest::setup();
    let contract_events = get_contract_events(&env, &contract.address);

    let contract_admin = contract.get_admin();

    assert_eq!(admin, contract_admin);
    assert_eq!(
        contract_events,
        vec![
            &env,
            (
                contract.address.clone(),
                vec![
                    &env,
                    *Symbol::new(&env, "contract_initialized").as_val(),
                ],
                (admin.clone(), token.0.address.clone()).into_val(&env)
            )
        ]
    );
}
```

> ğŸ’¡ This test ensures that the contract creation triggers the `initialize` event with the admin and token information, confirming that the initialization was recorded on the blockchain.

### ğŸ”¹ `add_car` Event

ğŸ“„ `src/tests/add_car.rs`

```rust
use soroban_sdk::{testutils::Address as _, Address, vec, IntoVal, Symbol};
use crate::{storage::{car::read_car, types::car_status::CarStatus}, tests::config::{contract::ContractTest, utils::get_contract_events}};

#[test]
pub fn test_add_car_successfully() {
    let ContractTest { env,  contract, .. } = ContractTest::setup();

    let owner = Address::generate(&env);
    let price_per_day = 1500_i128;

    contract.add_car( &owner, &price_per_day);
    let contract_events = get_contract_events(&env, &contract.address);

    let stored_car = env.as_contract(&contract.address, || {
        read_car(&env, &owner)
    });

    assert_eq!(stored_car.price_per_day, price_per_day);
    assert_eq!(stored_car.car_status, CarStatus::Available);

    assert_eq!(
        contract_events,
        vec![
            &env,
            (
                contract.address.clone(),
                vec![
                    &env,
                    *Symbol::new(&env, "car_added").as_val(),
                    owner.clone().into_val(&env),
                ],
                price_per_day.into_val(&env)
            )
        ]
    );
}
```

> ğŸ’¡ Verifies that every time a car is added, the `add_car` event is registered with the owner and price, guaranteeing traceability of listed cars.

### ğŸ”¹ `rental` Event

ğŸ“„ `src/tests/rental.rs`

```rust
use soroban_sdk::{testutils::Address as _, Address, vec, IntoVal, Symbol};
use crate::{storage::{car::read_car, contract_balance::read_contract_balance, rental::read_rental, types::car_status::CarStatus}, tests::config::{contract::ContractTest, utils::get_contract_events}};

#[test]
pub fn test_rental_car_successfully() {
    let ContractTest { env, contract, token, .. } = ContractTest::setup();

    let owner = Address::generate(&env);
    let renter = Address::generate(&env);
    let price_per_day = 1500_i128;
    let total_days = 3;
    let amount = 4500_i128;

    env.mock_all_auths();

    let (_, token_admin, _) = token;

    let amount_mint = 10_000_i128;
    token_admin.mint( &renter, &amount_mint);

    contract.add_car(&owner, &price_per_day);

    let initial_contract_balance = env.as_contract(&contract.address, || read_contract_balance(&env));
    assert_eq!(initial_contract_balance, 0);

    contract.rental(&renter, &owner, &total_days, &amount);
    let contract_events = get_contract_events(&env, &contract.address);

    let updated_contract_balance = env.as_contract(&contract.address, || read_contract_balance(&env));
    assert_eq!(updated_contract_balance, amount);

    let car = env.as_contract(&contract.address, || read_car(&env, &owner));
    assert_eq!(car.car_status, CarStatus::Rented);
    assert_eq!(car.available_to_withdraw, amount);

    let rental = env.as_contract(&contract.address, || read_rental(&env, &renter, &owner));
    assert_eq!(rental.total_days_to_rent, total_days);
    assert_eq!(rental.amount, amount);
        assert_eq!(
        contract_events,
        vec![
            &env,
            (
                contract.address.clone(),
                vec![
                    &env,
                    *Symbol::new(&env, "rented").as_val(),
                    renter.clone().into_val(&env),
                    owner.clone().into_val(&env),
                ],
                (total_days, amount).into_val(&env)
            )
        ]
    );
}
```

> ğŸ’¡ This test confirms that the `rental` event is emitted correctly with the reservation data, allowing auditing the action without directly querying the contract's internal state.

### ğŸ”¹ `payout_owner` Event

ğŸ“„ `src/tests/payout_owner.rs`

```rust
use soroban_sdk::{testutils::Address as _, Address, vec, IntoVal, Symbol};
use crate::{
    storage::{car::read_car, contract_balance::read_contract_balance},
    tests::config::{contract::ContractTest, utils::get_contract_events},
};

#[test]
pub fn test_payout_owner_successfully() {
    let ContractTest { env, contract, token, .. } = ContractTest::setup();

    let owner = Address::generate(&env);
    let renter = Address::generate(&env);
    let price_per_day = 1500_i128;
    let total_days = 3;
    let amount = 4500_i128;

    env.mock_all_auths();
    let (_, token_admin, _) = token;

    let amount_mint = 10_000_i128;
    token_admin.mint(&renter, &amount_mint);

    contract.add_car(&owner, &price_per_day);
    contract.rental(&renter, &owner, &total_days, &amount);

    let contract_balance = env.as_contract(&contract.address, || read_contract_balance(&env));
    assert_eq!(contract_balance, amount);

    contract.payout_owner(&owner, &amount);
    let contract_events = get_contract_events(&env, &contract.address);

    let car = env.as_contract(&contract.address, || read_car(&env, &owner));
    assert_eq!(car.available_to_withdraw, 0);

    let contract_balance = env.as_contract(&contract.address, || read_contract_balance(&env));
    assert_eq!(contract_balance, 0);
        assert_eq!(
        contract_events,
        vec![
            &env,
            (
                contract.address.clone(),
                vec![
                    &env,
                    *Symbol::new(&env, "payout").as_val(),
                    owner.clone().into_val(&env),
                ],
                amount.into_val(&env)
            )
        ]
    );
}
```

> ğŸ’¡ Allows verifying that payments to the owner are registered with an event, ensuring transparency and traceability of funds.

### ğŸ”¹ **`remove_car`** Event

ğŸ“„ `src/tests/remove_car.rs`

```rust
use soroban_sdk::{testutils::Address as _, Address, vec, IntoVal, Symbol};
use crate::{storage::car::has_car, tests::config::{contract::ContractTest, utils::get_contract_events}};

#[test]
pub fn test_remove_car_deletes_from_storage() {
    let ContractTest { env, contract, .. } = ContractTest::setup();

    let owner = Address::generate(&env);
    let price_per_day = 1500_i128;

    contract.add_car(&owner, &price_per_day);
    assert!(env.as_contract(&contract.address, || {
        has_car(&env, &owner)
    }));

    contract.remove_car(&owner);
    let contract_events = get_contract_events(&env, &contract.address);

    assert!(!env.as_contract(&contract.address, || {
        has_car(&env, &owner)
    }));

    assert_eq!(
        contract_events,
        vec![
            &env,
            (
                contract.address.clone(),
                vec![
                    &env,
                    *Symbol::new(&env, "car_removed").as_val(),
                    owner.clone().into_val(&env),
                ],
                ().into_val(&env)
            )
        ]
    );
}
```

> ğŸ’¡ This test confirms that when a car is deleted, the `remove_car` event is registered, allowing auditing all modifications to the car catalog.

---

With this test structure, we can **ensure that each critical function of the contract emits its corresponding event** and that the relevant data is correctly recorded, improving the system's traceability and reliability.

## ğŸ **Workshop 8 Closing**

In this session, we delved into how to **emit events and control authentication in our smart contract**:

- We understood what **events** are, how they are structured with `env.events().publish()`, and how to differentiate between **topics** and **data** so that the sent information is clear and useful for anyone consulting it.
- We learned to implement events in key functions like `initialize`, `deposit`, and `withdraw`, ensuring that every relevant action is recorded and can be reliably queried.
- We explored **authentication**, understanding how `require_auth()` allows us to validate that the person executing a function is indeed who they claim to be, and how this helps us restrict critical operations to authorized users, like the admin or the car owner in our RentACar.
- We tested events and authentication through **automated tests**, verifying that they are triggered correctly and that only users with permissions can execute certain functions.

> ğŸ” With these concepts, we acquired tools to guarantee traceability and security in our contract, ensuring that all actions are recorded via events and that only authorized users can interact with critical functions.
