# Workshop 10 ‚Äî Integration and Final dApp

# üéØ **Objective**

In this workshop, we will learn how to **connect a smart contract deployed on Soroban with an interactive frontend**, ensuring **security in private key management** and applying **best practices in decentralized application architecture**.

The goal is to understand **how users authenticate in Web3 environments**, what role wallets play within the Stellar ecosystem, and how to establish **secure communication between the frontend, the wallet, and the smart contract**.

Upon completion, you will be able to **integrate Stellar Wallet Kit**, sign transactions securely, and consume contract functions from different roles (administrator, owner, or user) through a visual interface.

---

## üîπ **Security and Connection Theory in Stellar dApps**

Developing decentralized applications on Stellar involves connecting several critical components: the contract on Soroban, the web frontend, and the user's wallet.

Each one fulfills a specific function, and their correct interaction guarantees both the **security** and **usability** of the system.

Unlike traditional applications, where identity is managed via usernames and passwords, in a dApp the identity is **linked to the user's cryptographic key**.

This completely transforms how actions are authenticated, signed, and executed within the application.

Next, we will explore three fundamental pillars of this secure architecture.

---

## üîê **1. Secure Management of Private Keys**

The private key is the **most sensitive element** of the Stellar ecosystem: it grants full control over an account and allows signing transactions on the network.

Therefore, it **should never be stored or handled directly from the frontend**.

In modern **decentralized applications**, this problem is solved using tools like **Stellar Wallet Kit**, which act as **secure intermediaries** between the user and the application.

The process is as follows:

1. The user **connects their wallet** from the interface.
2. The application requests the execution of a transaction.
3. The wallet **signs the transaction locally**, without exposing the private key.
4. The frontend only receives the signature and sends it to the network.

This "local signing" model ensures that **private keys never leave the user's device**, and no external application can access them.

Furthermore, the wallet validates the data before signing, which prevents common attacks like **malicious transactions or redirects to fake contracts**.

üëâ In summary, **security in Stellar depends on the isolation of the private key**, and as developers we must design the connection and signing flow so that no part of the system has direct access to it.

---

## üß† **2. Connection Architecture: Frontend ‚Üí Wallet ‚Üí Contract**

The architecture of a decentralized application on Stellar consists of three well-defined layers, which work in a coordinated but separate manner:

1. **Frontend:**

   It is the user interface that displays data and allows interaction with the contract's functions.

   This is where the visual business logic is implemented, but **never the contract logic or the keys**.

2. **Wallet Provider (Stellar Wallet Kit):**

   It is the **cryptographic bridge** between the application and the user's account.

   It manages the connection, authorization, and signing of transactions.

   Its function is to allow the user to act on the network without compromising their security.

3. **Smart Contract (Soroban):**

   It is the logical core of the system, where the business rules are defined:

   who can rent, how much to pay, how to distribute funds, etc.

   The contract has no knowledge of the frontend or the wallet; **it only processes valid signed addresses and values**.

The complete flow is:

1. The user connects to the application via their wallet.
2. The frontend builds a transaction and sends it to the wallet for signing.
3. The wallet signs and returns the transaction.
4. The contract executes the corresponding function (for example, `rental` or `payout_owner`).
5. The frontend shows the result in real-time through the contract's events.

üëâ This flow guarantees a **decentralized, secure, and auditable architecture**, where each layer fulfills its role without interfering with the others.

---

## üß© **3. Principle of Least Knowledge and Decoupling**

An essential principle in the secure design of **decentralized applications** (Least Knowledge Principle): each component of the system must **know only the information strictly necessary to fulfill its function**.

In the context of Stellar:

- The **frontend** must not know or store private keys.
- The **wallet** does not need to know the internal logic of the contract, only the data it signs.
- The **contract** does not need to know who the user is outside the network; it only validates addresses and on-chain permissions.

This decoupling improves the security and maintainability of the project.

If one part of the system fails (for example, a wallet stops working or a frontend is updated), **the rest of the components continue operating normally**.

Furthermore, applying this principle helps create **more auditable and modular infrastructures**, making it easier for other developers or teams to contribute without compromising the system's integrity.

üëâ Ultimately, a well-designed decentralized application is not only functional: it is **secure by design**, because each module has clear boundaries and well-defined responsibilities.

## üîπ What is Stellar Wallet Kit

**Stellar Wallet Kit** is a library that allows connecting **decentralized applications (dApps)** with **wallets in the Stellar ecosystem** in a secure and standardized way.

Its function is to **manage the connection, authentication, and signing of transactions** directly from the user's wallet, preventing the application from manipulating private keys or sensitive data.

### **Main Features:**

- üîê **Decentralized Authentication:** users connect using their wallet (Freighter, Rabet, xBull, among others), without needing passwords or additional accounts.
- ‚öôÔ∏è **Local Transaction Signing:** our application builds the transaction and the wallet takes care of signing and sending it to the network, guaranteeing security and traceability.
- üåê **Full Compatibility:** works on both **testnet** and **mainnet**, and allows interacting with **Soroban contracts** directly from the application's frontend, simplifying communication with the blockchain.
- üß† **Session and Event Management:** allows detecting network, account, or connection status changes in real-time to keep the UI synchronized.

### **Main Advantages:**

- **Security by Design:** private keys never leave the wallet.
- **Integration Simplicity:** abstracts the technical details of signatures and communication with the network.
- **Interoperability:** allows integrating multiple wallets with the same connection logic.

## üîπ Stellar Wallet Kit Resources

To delve deeper into auditing and best practices in Soroban contracts:

- **Official Repository:**
  - [GitHub](https://github.com/Creit-Tech/Stellar-Wallets-Kit)
- **Documentation:**
  - [Getting Started](https://stellarwalletskit.dev/)

## üîπ **Freighter Wallet**

**Freighter** is a wallet for Stellar designed for **users and developers**, which allows:

- Managing **private keys securely** without exposing them to the frontend.
- Connecting to **testnet and mainnet**, facilitating interactions with the Stellar blockchain.
- Signing transactions and **Soroban contract** operations directly from the browser.
- Easy integration with **Stellar Wallet Kit** and decentralized applications, ensuring a secure and controlled flow between user, frontend, and contract.

### üîπ **Freighter Wallet** Resources

To delve deeper into auditing and best practices in Soroban contracts:

- **Official Website:**
  - [Official Website](https://www.freighter.app/)

# üíª **Guided Demo: Creating Our First Decentralized Application**

In this section, we will show how users can **interact with the RentACar contract from a graphical interface**, using **Freighter Wallet** and **Stellar Wallet Kit**. The demo focuses on the dApp experience and the secure transaction flow, without needing to expose private keys in the frontend.

---

## 1Ô∏è‚É£ Create an Account in Freighter

Before interacting with the contract, each user must have an **account in Freighter**, which will serve to:

- Manage their **private key** securely.
- Connect to the **testnet or mainnet** of Stellar.
- Sign transactions and Soroban contract operations from the browser without exposing the key.

> üí° This step ensures all participants have a secure method of authentication and digital signing.

---

## 2Ô∏è‚É£ Create the Contract with the Freighter Public Key

When deploying the contract on Soroban, the **public key of the Freighter account** is used as the administrator. This allows:

- Establishing a **trusted admin** from the start.
- Associating car creation and maintenance permissions to a secure account.
- Guaranteeing that all critical operations have **verifiable authentication**.
  ```bash
  # Step 1
  cargo build --target wasm32v1-none --release

  # Step 2
  stellar contract optimize --wasm target/wasm32v1-none/release/rent_a_car.wasm

  # Step 3
  stellar contract deploy `
    --wasm target/wasm32v1-none/release/rent_a_car.optimized.wasm `
    --source admin `
    --network testnet `
    -- `
    --admin <freighter_public_key> `
    --token CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HHGCYSC

  # Step 4
  Add the contract to our `.env` file
  PUBLIC_CONTRACT_ADDRESS=<contract_id>
  ```

---

## 3Ô∏è‚É£ Create the Decentralized Application Interface

The base screens are built to allow interaction with the platform:

- Connect to a wallet
- Role selection: administrator, owner, or renting user
  ```tsx
  import { createContext, use, useCallback, useEffect, useState } from "react";
  import { IAccount } from "../interfaces/account";
  import {
    getAccountFromStorage,
    getCurrentAccountFromStorage,
    saveCurrentAccount,
  } from "../utils/local-storage";
  import { UserRole } from "../interfaces/user-role";
  import { ICar } from "../interfaces/car";

  interface StellarContextType {
    currentAccount: string;
    hashId: string;
    setHashId: React.Dispatch<React.SetStateAction<string>>;
    walletAddress: string;
    setWalletAddress: (address: string) => void;
    selectedRole: UserRole | null;
    setSelectedRole: (role: UserRole | null) => void;
    setCurrentAccount: (name: string) => void;
    getAccount: (name: string) => IAccount | null;
    getCurrentAccountData: () => IAccount | null;
    cars: ICar[];
    setCars: React.Dispatch<React.SetStateAction<ICar[]>>;
  }

  const StellarAccountContext = createContext<StellarContextType | undefined>(
    undefined,
  );

  export const useStellarAccounts = () => {
    const context = use(StellarAccountContext);
    if (context === undefined) {
      throw new Error(
        "useStellarAccounts must be used within a StellarAccountProvider",
      );
    }
    return context;
  };

  export const StellarAccountProvider: React.FC<{
    children: React.ReactNode;
  }> = ({ children }) => {
    const [walletAddress, setWalletAddress] = useState<string>(() => {
      return localStorage.getItem("wallet") || "";
    });

    const [currentAccount, setCurrentAccountState] = useState<string>(() =>
      getCurrentAccountFromStorage(),
    );

    const [hashId, setHashId] = useState<string>("");

    const [selectedRole, setSelectedRole] = useState<UserRole | null>(() => {
      const saved = localStorage.getItem("role");
      return saved ? (saved as UserRole) : null;
    });

    const [cars, setCars] = useState<ICar[]>(() => {
      const savedCars = localStorage.getItem("cars");
      return savedCars ? (JSON.parse(savedCars) as ICar[]) : [];
    });

    const setCurrentAccount = useCallback((name: string) => {
      setCurrentAccountState(name);
      saveCurrentAccount(name);
    }, []);

    const getAccount = useCallback((name: string): IAccount | null => {
      return getAccountFromStorage(name);
    }, []);

    const getCurrentAccountData = useCallback((): IAccount | null => {
      if (!currentAccount) return null;
      return getAccountFromStorage(currentAccount);
    }, [currentAccount]);

    useEffect(() => {
      if (walletAddress) {
        localStorage.setItem("wallet", walletAddress);
      }
    }, [walletAddress]);

    useEffect(() => {
      if (selectedRole) {
        localStorage.setItem("role", selectedRole);
      }
    }, [selectedRole]);

    useEffect(() => {
      localStorage.setItem("cars", JSON.stringify(cars));
    }, [cars]);

    const value: StellarContextType = {
      walletAddress,
      currentAccount,
      hashId,
      setHashId,
      setWalletAddress,
      setCurrentAccount,
      getAccount,
      selectedRole,
      setSelectedRole,
      getCurrentAccountData,
      cars,
      setCars,
    };

    return (
      <StellarAccountContext value={value}>{children}</StellarAccountContext>
    );
  };
  ```
- Listing and status of cars (`Available`, `Rented`, `Maintenance`)

üìÑ `src/utils/constants.ts`

```tsx
const {
  PUBLIC_STELLAR_NETWORK: STELLAR_NETWORK,
  PUBLIC_STELLAR_NETWORK_PASSPHRASE: HORIZON_NETWORK_PASSPHRASE,
  PUBLIC_STELLAR_HORIZON_URL: HORIZON_URL,
  PUBLIC_STELLAR_RPC_URL: SOROBAN_RPC_URL,
  PUBLIC_STELLAR_FRIENDBOT_URL: STELLAR_FRIENDBOT_URL,
  PUBLIC_CONTRACT_ADDRESS: CONTRACT_ADDRESS,
} = import.meta.env;

export {
  STELLAR_NETWORK,
  HORIZON_NETWORK_PASSPHRASE,
  HORIZON_URL,
  SOROBAN_RPC_URL,
  STELLAR_FRIENDBOT_URL,
  CONTRACT_ADDRESS,
};
```

üìÑ `src/providers/Providers.tsx`

üìÑ `src/App.tsx`

```tsx
import { Button, Layout, Profile } from "@stellar/design-system";
import { Outlet, Route, Routes } from "react-router-dom";
import AccountManager from "./components/AccountManager";
import { shortenAddress } from "./utils/shorten-address";
import ConnectWallet from "./pages/WalletConnect";
import { useStellarAccounts } from "./providers/Provider";
import RoleSelection from "./pages/RoleSelection";
import Dashboard from "./pages/Dashboard";
import { NavLink } from "react-router-dom";

const AppLayout: React.FC = () => {
  const { walletAddress, selectedRole } = useStellarAccounts();

  return (
    <main>
      <Layout.Header
        projectId="My App"
        projectTitle="Rent a car"
        contentCenter={
          <>
            <nav className="flex justify-between gap-8">
              <NavLink
                to="/"
                className={({ isActive }) =>
                  `font-medium transition-colors duration-200 ${
                    isActive
                      ? "text-blue-600 border-b-2 border-blue-600 pb-1"
                      : "text-gray-700 hover:text-blue-600"
                  }`
                }
              >
                Connect Wallet
              </NavLink>

              <NavLink
                to="/role-selection"
                className={({ isActive }) =>
                  `font-medium transition-colors duration-200 ${
                    isActive
                      ? "text-blue-600 border-b-2 border-blue-600 pb-1"
                      : "text-gray-700 hover:text-blue-600"
                  }`
                }
              >
                Select Role
              </NavLink>

              {selectedRole && (
                <NavLink
                  to="/cars"
                  className={({ isActive }) =>
                    `font-medium transition-colors duration-200 ${
                      isActive
                        ? "text-blue-600 border-b-2 border-blue-600 pb-1"
                        : "text-gray-700 hover:text-blue-600"
                    }`
                  }
                >
                  Car List
                </NavLink>
              )}
            </nav>
          </>
        }
        contentRight={
          <>
            <nav>
              {walletAddress && (
                <Button variant="tertiary" size="md">
                  <Profile
                    publicAddress={shortenAddress(walletAddress)}
                    size="md"
                  />
                </Button>
              )}
            </nav>
          </>
        }
      />
      <div className="min-h-[65vh]">
        <Outlet />
      </div>
      <Layout.Footer>
        <span>
          ¬© {new Date().getFullYear()} My App. Licensed under the{" "}
          <a
            href="http://www.apache.org/licenses/LICENSE-2.0"
            target="_blank"
            rel="noopener noreferrer"
          >
            Apache License, Version 2.0
          </a>
          .
        </span>
      </Layout.Footer>
    </main>
  );
};

export default function App() {
  return (
    <Routes>
      <Route element={<AppLayout />}>
        <Route path="/" element={<ConnectWallet />} />
        <Route path="/role-selection" element={<RoleSelection />} />
        <Route path="/cars" element={<Dashboard />} />
        <Route path="/horizon-example" element={<AccountManager />} />
      </Route>
    </Routes>
  );
}
```

üìÑ `src/utils/shorten-address.ts`

```tsx
export const shortenAddress = (address: string) => {
  if (!address) return "";
  const first = address.slice(0, 4);
  const last = address.slice(-4);
  return `${first}...${last}`;
};
```

üìÑ `src/utils/xlm-in-stroops.ts`

```tsx
export const ONE_XLM_IN_STROOPS = 10_000_000;
```

üìÑ `src/interfaces/user-role.ts`

```tsx
export enum UserRole {
  OWNER = "owner",
  RENTER = "renter",
  ADMIN = "admin",
}
```

üìÑ `src/interfaces/car-status.ts`

```tsx
export enum CarStatus {
  AVAILABLE = "Available",
  RENTED = "Rented",
  MAINTENANCE = "Maintenance",
}
```

üìÑ `src/interfaces/car.ts`

```tsx
import { CarStatus } from "./car-status";

export interface ICar {
  brand: string;
  model: string;
  color: string;
  passengers: number;
  ac: boolean;
  pricePerDay: number;
  status: CarStatus;
  ownerAddress: string;
}
```

üìÑ `src/interfaces/create-car.ts`

```tsx
import { ICar } from "./car";

export type CreateCar = Omit<ICar, "status">;
```

üìÑ `src/pages/ConnectWallet.ts`

```tsx
import { Button, Icon, Text } from "@stellar/design-system";
import { useState } from "react";
import { useNavigate } from "react-router-dom";
import { useStellarAccounts } from "../providers/Provider";
import { walletService } from "../services/wallet.service";

export default function ConnectWallet() {
  const [isConnecting, setIsConnecting] = useState(false);
  const { setWalletAddress } = useStellarAccounts();
  const navigate = useNavigate();

  const handleConnectWallet = async () => {
    setIsConnecting(true);

    try {
      const address = await walletService.connect();
      localStorage.setItem("wallet", address);

      setWalletAddress(address);
      void navigate("/role-selection");
    } catch (error) {
      console.error(error);
      setIsConnecting(false);
    } finally {
      setIsConnecting(false);
    }
  };

  return (
    <div className="flex items-center justify-center bg-background">
      <div className="text-center space-y-8 max-w-md px-4">
        <div className="space-y-4">
          <h1 className="text-5xl font-bold text-foreground text-balance uppercase">
            Stellar Car Rental
          </h1>
          <Text as="p" size="lg">
            Connect your wallet to access the decentralized rental platform
          </Text>
        </div>

        <div className="flex justify-center">
          <Button
            onClick={() => void handleConnectWallet()}
            disabled={isConnecting}
            size="xl"
            variant="primary"
          >
            {isConnecting ? (
              <>
                <div className="w-6 h-6 border-2 border-primary-foreground/30 border-t-primary-foreground rounded-full animate-spin" />
                Connecting...
              </>
            ) : (
              <>
                <Icon.Wallet02 className="w-6 h-6" />
                Connect Wallet
              </>
            )}
          </Button>
        </div>
      </div>
    </div>
  );
}
```

üìÑ `src/pages/RoleSelection.tsx`

```tsx
export default function RoleSelection() {
  const { setSelectedRole, selectedRole } = useStellarAccounts();
  const navigate = useNavigate();

  const handleRoleSelect = (role: UserRole) => {
    localStorage.setItem("role", role);
    setSelectedRole(role);

    void navigate("/cars");
  };

  return (
    <div className="container mx-auto px-4 py-16">
      <div className="max-w-4xl mx-auto text-center space-y-12">
        <div className="space-y-4">
          <Heading as="h1" size="lg">
            Select your role
          </Heading>
          <Text size="lg" as="p">
            Do you want to hire a vehicle, put yours up for hire, or withdraw
            your earnings?
          </Text>
        </div>

        <div className="grid md:grid-cols-3 gap-6">
          <button
            onClick={() => handleRoleSelect(UserRole.ADMIN)}
            className={`group relative p-8 rounded-xl border-2 transition-all duration-300 hover:scale-105 hover:shadow-2xl cursor-pointer ${
              selectedRole === UserRole.ADMIN
                ? "border-purple-600 bg-purple-50 shadow-xl shadow-purple-200"
                : "border-gray-200 bg-white hover:border-purple-400 hover:shadow-xl hover:shadow-purple-100"
            }`}
          >
            <div className="space-y-4">
              <div
                className={`inline-block p-4 rounded-full transition-all duration-300 ${
                  selectedRole === UserRole.ADMIN
                    ? "bg-purple-100"
                    : "bg-purple-50 group-hover:bg-purple-100"
                }`}
              >
                <Icon.UserSquare
                  className={`w-12 h-12 transition-colors duration-300 ${
                    selectedRole === UserRole.ADMIN
                      ? "text-purple-600"
                      : "text-purple-500 group-hover:text-purple-600"
                  }`}
                />
              </div>
              <Heading as="h2" size="md" className="text-gray-900">
                Admin
              </Heading>
              <Text size="lg" as="p" className="text-gray-600">
                Create the cars for hire and you can remove them.
              </Text>
            </div>
          </button>

          <button
            onClick={() => handleRoleSelect(UserRole.OWNER)}
            className={`group relative p-8 rounded-xl border-2 transition-all duration-300 hover:scale-105 hover:shadow-2xl cursor-pointer ${
              selectedRole === UserRole.OWNER
                ? "border-green-600 bg-green-50 shadow-xl shadow-green-200"
                : "border-gray-200 bg-white hover:border-green-400 hover:shadow-xl hover:shadow-green-100"
            }`}
          >
            <div className="space-y-4">
              <div
                className={`inline-block p-4 rounded-full transition-all duration-300 ${
                  selectedRole === UserRole.OWNER
                    ? "bg-green-100"
                    : "bg-green-50 group-hover:bg-green-100"
                }`}
              >
                <Icon.Car01
                  className={`w-12 h-12 transition-colors duration-300 ${
                    selectedRole === UserRole.OWNER
                      ? "text-green-600"
                      : "text-green-500 group-hover:text-green-600"
                  }`}
                />
              </div>
              <Heading as="h2" size="md" className="text-gray-900">
                Owner
              </Heading>
              <Text size="lg" as="p" className="text-gray-600">
                Check the status of your car and collect the profits generated
              </Text>
            </div>
          </button>

          <button
            onClick={() => handleRoleSelect(UserRole.RENTER)}
            className={`group relative p-8 rounded-xl border-2 transition-all duration-300 hover:scale-105 hover:shadow-2xl cursor-pointer ${
              selectedRole === UserRole.RENTER
                ? "border-blue-600 bg-blue-50 shadow-xl shadow-blue-200"
                : "border-gray-200 bg-white hover:border-blue-400 hover:shadow-xl hover:shadow-blue-100"
            }`}
          >
            <div className="space-y-4">
              <div
                className={`inline-block p-4 rounded-full transition-all duration-300 ${
                  selectedRole === UserRole.RENTER
                    ? "bg-blue-100"
                    : "bg-blue-50 group-hover:bg-blue-100"
                }`}
              >
                <Icon.UserCircle
                  className={`w-12 h-12 transition-colors duration-300 ${
                    selectedRole === UserRole.RENTER
                      ? "text-blue-600"
                      : "text-blue-500 group-hover:text-blue-600"
                  }`}
                />
              </div>
              <Heading as="h2" size="md" className="text-gray-900">
                Renter
              </Heading>
              <Text as="p" size="lg" className="text-gray-600">
                Browse available vehicles and hire the one you need in a
                transparent manner
              </Text>
            </div>
          </button>
        </div>
      </div>
    </div>
  );
}
```

üìÑ `src/pages/Dashboard.tsx`

```tsx
import { CarsList } from "../components/CarList";
import { CreateCarForm } from "../components/CreateCarForm";
import StellarExpertLink from "../components/StellarExpertLink";
import useModal from "../hooks/useModal";
import { ICar } from "../interfaces/car";
import { CarStatus } from "../interfaces/car-status";
import { IRentACarContract } from "../interfaces/contract";
import { CreateCar } from "../interfaces/create-car";
import { UserRole } from "../interfaces/user-role";
import { useStellarAccounts } from "../providers/Provider";
import { stellarService } from "../services/stellar.service";
import { walletService } from "../services/wallet.service";
import { ONE_XLM_IN_STROOPS } from "../utils/xlm-in-stroops";

export default function Dashboard() {
  const { hashId, cars, walletAddress, setCars, setHashId, selectedRole } =
    useStellarAccounts();
  const { showModal, openModal, closeModal } = useModal();

  const handleCreateCar = async (formData: CreateCar) => {
    const { brand, model, color, passengers, pricePerDay, ac, ownerAddress } =
      formData;
    const contractClient =
      await stellarService.buildClient<IRentACarContract>(walletAddress);

    const addCarResult = await contractClient.add_car({
      owner: ownerAddress,
      price_per_day: pricePerDay * ONE_XLM_IN_STROOPS,
    });
    const xdr = addCarResult.toXDR();

    const signedTx = await walletService.signTransaction(xdr);
    const txHash = await stellarService.submitTransaction(signedTx.signedTxXdr);

    const newCar: ICar = {
      brand,
      model,
      color,
      passengers,
      pricePerDay,
      ac,
      ownerAddress,
      status: CarStatus.AVAILABLE,
    };

    setCars((prevCars) => [...prevCars, newCar]);
    setHashId(txHash as string);
    closeModal();
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold" data-test="dashboard-title">
          Cars Catalog
        </h1>
        {selectedRole === UserRole.ADMIN && (
          <button
            onClick={openModal}
            className="group px-6 py-3 bg-indigo-600 text-white font-semibold rounded-xl shadow-lg hover:bg-indigo-700 hover:shadow-xl disabled:bg-slate-300 disabled:cursor-not-allowed transition-all duration-200 transform hover:scale-105 disabled:transform-none cursor-pointer"
          >
            <span className="flex items-center gap-2">Add Car</span>
          </button>
        )}
      </div>

      {cars && <CarsList cars={cars} />}

      {showModal && (
        <CreateCarForm onCreateCar={handleCreateCar} onCancel={closeModal} />
      )}

      {hashId && <StellarExpertLink url={hashId} />}
    </div>
  );
}
```

üìÑ `src/components/CreateCarForm.tsx`

```tsx
import { useState } from "react";
import { CreateCar } from "../interfaces/create-car";
import Modal from "./Modal";

interface CreateCarFormProps {
  onCreateCar: (formData: CreateCar) => Promise<void>;
  onCancel: () => void;
}

export const CreateCarForm = ({
  onCreateCar,
  onCancel,
}: CreateCarFormProps) => {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [formData, setFormData] = useState<CreateCar>({
    brand: "",
    model: "",
    color: "",
    passengers: 1,
    pricePerDay: 0,
    ac: false,
    ownerAddress: "",
  });

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value, type, checked } = e.target;
    setFormData((prev) => ({
      ...prev,
      [name]:
        type === "checkbox"
          ? checked
          : type === "number"
            ? Number(value)
            : value,
    }));
  };

  const handleSubmit = async (
    e: React.FormEvent<HTMLFormElement>,
  ): Promise<void> => {
    e.preventDefault();
    setIsSubmitting(true);

    try {
      await onCreateCar(formData);
    } catch (error) {
      console.error("Error creating car:", error);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Modal title="Create New Car" closeModal={onCancel}>
      <div className="bg-white rounded-lg px-8">
        <form onSubmit={(e) => void handleSubmit(e)} className="space-y-4">
          <div>
            <label
              htmlFor="brand"
              className="block text-sm font-medium text-gray-700"
            >
              Brand
            </label>
            <input
              id="brand"
              name="brand"
              type="text"
              value={formData.brand}
              onChange={handleChange}
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 p-1"
            />
          </div>

          <div>
            <label
              htmlFor="model"
              className="block text-sm font-medium text-gray-700"
            >
              Model
            </label>
            <input
              id="model"
              name="model"
              type="text"
              value={formData.model}
              onChange={handleChange}
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 p-1"
            />
          </div>

          <div>
            <label
              htmlFor="color"
              className="block text-sm font-medium text-gray-700"
            >
              Color
            </label>
            <input
              id="color"
              name="color"
              type="text"
              value={formData.color}
              onChange={handleChange}
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 p-1"
            />
          </div>

          <div>
            <label
              htmlFor="passengers"
              className="block text-sm font-medium text-gray-700"
            >
              Number of Passengers
            </label>
            <input
              id="passengers"
              name="passengers"
              type="number"
              min="1"
              max="10"
              value={formData.passengers}
              onChange={handleChange}
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 p-1"
            />
          </div>

          <div>
            <label
              htmlFor="pricePerDay"
              className="block text-sm font-medium text-gray-700"
            >
              Price per Day
            </label>
            <input
              id="pricePerDay"
              name="pricePerDay"
              type="number"
              min="0"
              value={formData.pricePerDay}
              onChange={handleChange}
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 p-1"
            />
          </div>

          <div>
            <label
              htmlFor="ownerAddress"
              className="block text-sm font-medium text-gray-700"
            >
              Owner Address
            </label>
            <input
              id="ownerAddress"
              name="ownerAddress"
              type="text"
              value={formData.ownerAddress}
              onChange={handleChange}
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 p-1"
            />
          </div>

          <div className="flex items-center">
            <input
              id="ac"
              name="ac"
              type="checkbox"
              checked={formData.ac}
              onChange={handleChange}
              className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
            />
            <label htmlFor="ac" className="ml-2 block text-sm text-gray-700">
              Air Conditioning
            </label>
          </div>

          <div className="flex justify-end gap-4 space-x-3 pt-2 pb-6">
            {onCancel && (
              <button
                type="button"
                onClick={onCancel}
                className="px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 cursor-pointer"
              >
                Cancel
              </button>
            )}
            <button
              type="submit"
              disabled={isSubmitting}
              className="px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:bg-gray-400 cursor-pointer"
            >
              {isSubmitting ? "Creating..." : "Create Car"}
            </button>
          </div>
        </form>
      </div>
    </Modal>
  );
};
```

üìÑ `src/components/CarList.tsx`

```tsx
import { ICar } from "../interfaces/car";
import { CarStatus } from "../interfaces/car-status";
import { IRentACarContract } from "../interfaces/contract";
import { UserRole } from "../interfaces/user-role";
import { useStellarAccounts } from "../providers/Provider";
import { stellarService } from "../services/stellar.service";
import { walletService } from "../services/wallet.service";
import { shortenAddress } from "../utils/shorten-address";
import { ONE_XLM_IN_STROOPS } from "../utils/xlm-in-stroops";

interface CarsListProps {
  cars: ICar[];
}

export const CarsList = ({ cars }: CarsListProps) => {
  const { walletAddress, selectedRole, setHashId, setCars } =
    useStellarAccounts();

  const handleDelete = async (owner: string) => {
    const contractClient =
      await stellarService.buildClient<IRentACarContract>(walletAddress);

    const result = await contractClient.remove_car({ owner });
    const xdr = result.toXDR();

    const signedTx = await walletService.signTransaction(xdr);
    const txHash = await stellarService.submitTransaction(signedTx.signedTxXdr);

    setCars((prev) => prev.filter((car) => car.ownerAddress !== owner));
    setHashId(txHash as string);
  };

  const handlePayout = async (owner: string, amount: number) => {
    const contractClient =
      await stellarService.buildClient<IRentACarContract>(walletAddress);

    const result = await contractClient.payout_owner({ owner, amount });
    const xdr = result.toXDR();

    const signedTx = await walletService.signTransaction(xdr);
    const txHash = await stellarService.submitTransaction(signedTx.signedTxXdr);

    setHashId(txHash as string);
  };

  const handleRent = async (
    car: ICar,
    renter: string,
    totalDaysToRent: number,
  ) => {
    const contractClient =
      await stellarService.buildClient<IRentACarContract>(walletAddress);

    const result = await contractClient.rental({
      renter,
      owner: car.ownerAddress,
      total_days_to_rent: totalDaysToRent,
      amount: car.pricePerDay * totalDaysToRent * ONE_XLM_IN_STROOPS,
    });
    const xdr = result.toXDR();

    const signedTx = await walletService.signTransaction(xdr);
    const txHash = await stellarService.submitTransaction(signedTx.signedTxXdr);

    setCars((prev) =>
      prev.map((c) =>
        c.ownerAddress === car.ownerAddress
          ? { ...c, status: CarStatus.RENTED }
          : c,
      ),
    );
    setHashId(txHash as string);
  };

  const getStatusStyle = (status: CarStatus) => {
    switch (status) {
      case CarStatus.AVAILABLE:
        return "px-2 py-1 text-xs font-semibold rounded-full bg-green-100 text-green-800";
      case CarStatus.RENTED:
        return "px-2 py-1 text-xs font-semibold rounded-full bg-blue-100 text-blue-800";
      case CarStatus.MAINTENANCE:
        return "px-2 py-1 text-xs font-semibold rounded-full bg-yellow-100 text-yellow-800";
      default:
        return "px-2 py-1 text-xs font-semibold rounded-full bg-gray-100 text-gray-800";
    }
  };

  const renderActionButton = (car: ICar) => {
    if (selectedRole === UserRole.ADMIN) {
      return (
        <button
          onClick={() => void handleDelete(car.ownerAddress)}
          className="px-3 py-1 bg-red-600 text-white rounded font-semibold hover:bg-red-700 transition-colors cursor-pointer"
        >
          Delete
        </button>
      );
    }

    if (selectedRole === UserRole.OWNER) {
      const amount = car.pricePerDay * 3 * ONE_XLM_IN_STROOPS;
      return (
        <button
          onClick={() => void handlePayout(car.ownerAddress, amount)}
          className="px-3 py-1 bg-green-600 text-white rounded font-semibold hover:bg-green-700 transition-colors cursor-pointer"
        >
          Withdraw
        </button>
      );
    }

    if (
      selectedRole === UserRole.RENTER &&
      car.status === CarStatus.AVAILABLE
    ) {
      return (
        <button
          onClick={() => void handleRent(car, walletAddress, 3)}
          className="px-3 py-1 bg-blue-600 text-white rounded font-semibold hover:bg-blue-700 transition-colors cursor-pointer"
        >
          Rent
        </button>
      );
    }

    return null;
  };

  return (
    <div data-test="cars-list">
      <div>
        <table className="min-w-full bg-white shadow-md rounded-lg">
          <thead className="bg-gray-50">
            <tr>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Brand
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Model
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Color
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Passengers
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                A/C
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Owner
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Price/Day
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Status
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Actions
              </th>
            </tr>
          </thead>
          <tbody className="divide-y divide-gray-200">
            {cars.map((car, index) => (
              <tr key={index} className="hover:bg-gray-50">
                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                  {car.brand}
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                  {car.model}
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                  {car.color}
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                  {car.passengers}
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                  {car.ac ? (
                    <span className="text-green-600">Yes</span>
                  ) : (
                    <span className="text-red-600">No</span>
                  )}
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                  {shortenAddress(car.ownerAddress)}
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                  ${car.pricePerDay}
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                  <span className={getStatusStyle(car.status)}>
                    {car.status}
                  </span>
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                  {renderActionButton(car)}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
};
```

> üí° This layer **does not execute blockchain logic yet**, but it defines the user's navigation and visual experience.

---

## 4Ô∏è‚É£ Connect Wallet with Stellar Wallet Kit

**Freighter** is integrated as the main wallet to:

- Obtain the user's **public address**
- Sign transactions with their **private key (NEVER exposed to the application)**
- Guarantee a secure flow between **UI ‚Üí Wallet ‚Üí Blockchain**

üìÑ `src/services/wallet.service.ts`

```tsx
import {
  AlbedoModule,
  FREIGHTER_ID,
  FreighterModule,
  type ISupportedWallet,
  StellarWalletsKit,
  WalletNetwork,
  xBullModule,
} from "@creit.tech/stellar-wallets-kit";
import { stellarService, StellarService } from "./stellar.service";

export class WalletService {
  private readonly kit: StellarWalletsKit;
  private readonly stellarService: StellarService;

  constructor(stellarService: StellarService) {
    this.stellarService = stellarService;
    this.kit = new StellarWalletsKit({
      network: WalletNetwork.TESTNET,
      selectedWalletId: FREIGHTER_ID,
      modules: [new xBullModule(), new FreighterModule(), new AlbedoModule()],
    });
  }

  async connect(): Promise<string> {
    return new Promise((resolve, reject) => {
      void this.kit.openModal({
        onWalletSelected: (option: ISupportedWallet) => {
          this.kit.setWallet(option.id);
          this.kit
            .getAddress()
            .then(({ address }) => resolve(address))
            .catch((error) =>
              reject(error instanceof Error ? error : new Error(String(error))),
            );
        },
      });
    });
  }

  async disconnect(): Promise<void> {
    await this.kit.disconnect();
  }

  async signTransaction(xdr: string): Promise<{
    signedTxXdr: string;
    signedAddress?: string;
  }> {
    const environment = this.stellarService.environment();
    return await this.kit.signTransaction(xdr, {
      networkPassphrase: environment.networkPassphrase,
    });
  }
}

export const walletService = new WalletService(stellarService);
```

> üí° Stellar Wallet Kit simplifies connection to multiple wallets and reduces security risks.

---

## 5Ô∏è‚É£ Integrate the Contract with Stellar Service

The `RentACarContract` interface is defined and functions are added to the **`StellarService`**. These functions will be invoked from the UI to consume the smart contract directly from the browser, triggering each business flow on the blockchain.

üìÑ `src/interfaces/contract.ts`

```tsx
import type { ClientOptions } from "@stellar/stellar-sdk/contract";
import { CarStatus } from "./car-status";

export interface IBaseContractClient {
  readonly options: ClientOptions;
  toXDR(): string;
}

export interface IRentACarContract extends IBaseContractClient {
  __constructor: ({
    admin,
    token,
  }: {
    admin: string;
    token: string;
  }) => Promise<this>;

  add_car: ({
    owner,
    price_per_day,
  }: {
    owner: string;
    price_per_day: number;
  }) => Promise<this>;

  get_car_status: ({ owner }: { owner: string }) => Promise<CarStatus>;

  rental: ({
    renter,
    owner,
    total_days_to_rent,
    amount,
  }: {
    renter: string;
    owner: string;
    total_days_to_rent: number;
    amount: number;
  }) => Promise<this>;

  remove_car: ({ owner }: { owner: string }) => Promise<this>;

  payout_owner: ({
    owner,
    amount,
  }: {
    owner: string;
    amount: number;
  }) => Promise<this>;
}
```

üìÑ `src/services/stellar.service.ts`

```tsx
import {
  Asset,
  BASE_FEE,
  Claimant,
  contract,
  Horizon,
  Keypair,
  Operation,
  rpc,
  TransactionBuilder,
  xdr,
} from "@stellar/stellar-sdk";
import {
  CONTRACT_ADDRESS,
  HORIZON_NETWORK_PASSPHRASE,
  HORIZON_URL,
  SOROBAN_RPC_URL,
  STELLAR_FRIENDBOT_URL,
  STELLAR_NETWORK,
} from "../utils/constants";
import { IKeypair } from "../interfaces/keypair";
import { IAccountBalanceResponse } from "../interfaces/balance";
import { AccountBalance } from "../interfaces/account";
import { ICreateClaimableBalanceResponse } from "../interfaces/claimable-balance";

export class StellarService {
  private network: string;
  private horizonUrl: string;
  private server: Horizon.Server;
  private rpcServer: rpc.Server;
  private friendBotUrl: string;
  private networkPassphrase: string;

  constructor() {
    this.network = STELLAR_NETWORK as string;
    this.horizonUrl = HORIZON_URL as string;
    this.rpcUrl = SOROBAN_RPC_URL as string;
    this.friendBotUrl = STELLAR_FRIENDBOT_URL as string;
    this.networkPassphrase = HORIZON_NETWORK_PASSPHRASE as string;
    this.contractAddress = CONTRACT_ADDRESS as string;

    this.server = new Horizon.Server(this.horizonUrl, {
      allowHttp: true,
    });
    this.rpcServer = new rpc.Server(this.rpcUrl, {
      allowHttp: true,
    });
  }

  async buildClient<T = unknown>(publicKey: string): Promise<T> {
    const client = await contract.Client.from({
      contractId: this.contractAddress,
      rpcUrl: this.rpcUrl,
      networkPassphrase: this.networkPassphrase,
      publicKey,
    });

    return client as T;
  }

  async submitTransaction(xdr: string): Promise<string | undefined> {
    try {
      const transaction = TransactionBuilder.fromXDR(
        xdr,
        this.networkPassphrase,
      );
      const result = await this.server.submitTransaction(transaction);

      return result.hash;
    } catch (error) {
      console.error(error);
      if (error.response?.data?.extras?.result_codes) {
        console.error(
          "‚ùå Error en la transacci√≥n:",
          error.response.data.extras.result_codes,
        );
      } else {
        console.error("‚ùå Error general:", error);
      }
    }
  }

  environment(): { rpc: string; networkPassphrase: string } {
    return {
      rpc: this.rpcUrl,
      networkPassphrase: this.networkPassphrase,
    };
  }
}

export const stellarService = new StellarService();
```

---

> üí° **This layer connects the UI with the blockchain: the dApp builds the operation ‚Üí Wallet signs it ‚Üí Soroban validates it ‚Üí the UI shows the real state of the contract.**

## üèÅ **Closing of the Final Workshop**

In this final session, we took the decisive step: **we connected our smart contract on Soroban with a real web application**, integrating all the parts that make a complete dApp on Stellar possible.

During the workshop, we achieved:

- Understanding the role of the **wallet as a secure manager of private keys** and how it enables decentralized identity.
- Integrating **Stellar Wallet Kit** to connect accounts, authenticate, and sign transactions without exposing sensitive data.
- Interacting from the UI with contract functions like `rental` and `payout_owner`, following a secure and auditable flow.
- Applying a **layered architecture**:
  UI ‚Üí Wallet ‚Üí Blockchain, keeping each module decoupled and with clear responsibilities.
- Validating results in real-time through interface updates.

> üîê This workshop allowed us to unite frontend, wallet, and blockchain securely, making our on-chain actions part of a simple and intuitive user experience.

---

### üîπ Bootcamp Completed üöÄ

With this, **we close the complete Bootcamp** ‚úÖ

We have covered all the essential pillars of Web3 development on Stellar:

- How to **model contracts** and structure their storage
- How to **separate on-chain and off-chain logic** with best practices
- How to **build** and **sign real operations** on the blockchain
- How to **transform that logic into an application usable** by anyone

> üéØ Today you already have the fundamentals to create your own decentralized applications on Stellar, from the idea to its real implementation on the network.

---

üíô‚ú® **Thank you for all the commitment, the tests, the progress, and the enthusiasm!**

What we built together here is just the beginning‚Ä¶

**See you in the next challenge üöÄ**
